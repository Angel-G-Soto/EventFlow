<?php

namespace App\Services;

use App\Models\Category;
use App\Models\Document;
use App\Models\Event;
use App\Models\User;
Use App\Models\Venue;
use Illuminate\Support\Facades\DB;

class EventService {

    // Injected services
    //protected $eventHistoryService;
    protected $venueService;
    protected $categoryService;

    // Construct
    public function __construct(VenueService $venueService, CategoryService $categoryService)
    {
        $this->venueService = $venueService;
        $this->categoryService = $categoryService;
    }

    // Methods

        // FORM

        public function updateOrCreateFromEventForm(array $data, array $document_ids, array $categories_ids, User $creator, string $action)
        {
            return DB::transaction(function () use ($data, $document_ids, $categories_ids, $creator, $action) {
                // Validate existence of related entities
                if (!User::where('id', $creator->id)->exists()) {
                    abort(404, 'Author not found.');
                }

                if (!isset($data['venue_id']) || !Venue::where('id', $data['venue_id'])->exists()) {
                    abort(404, 'Venue not found.');
                }

                // Determine status based on user action and advisor presence
                $status = match ($action) {
                    'draft'   => 'draft',
                    'publish' => !empty($data['organization_advisor_email'])
                        ? 'pending - advisor approval'
                        : 'pending - approval', // fallback if advisor not set
                    default   => 'draft',
                };

                // Create or update the event
                $event = Event::updateOrCreate(
                    [
                        'id' => $data['id'] ?? null, // If provided, updates existing event
                    ],
                    [
                        'creator_id' => $creator->id,
                        'venue_id' => $data['venue_id'],

                        'organization_name' => $data['organization_name'] ?? null,
                        'organization_advisor_name' => $data['organization_advisor_name'] ?? null,
                        'organization_advisor_email' => $data['organization_advisor_email'] ?? null,
                        'organization_advisor_phone' => $data['organization_advisor_phone'] ?? null,

                        'creator_institutional_number' => $data['creator_institutional_number'] ?? null,
                        'creator_phone_number' => $data['creator_phone_number'] ?? null,

                        'title' => $data['title'],
                        'description' => $data['description'] ?? null,
                        'start_time' => $data['start_time'],
                        'end_time' => $data['end_time'],

                        'status' => $status,
                        'guest_size' => $data['guests'] ?? null,
                        'handles_food' => $data['handles_food'] ?? false,
                        'use_institutional_funds' => $data['use_institutional_funds'] ?? false,
                        'external_guest' => $data['external_guests'] ?? false,
                    ]
                );

                // Attach documents (hasMany)
                if (!empty($document_ids)) {
                    Document::whereIn('id', $document_ids)
                        ->update(['event_id' => $event->id]);
                }

                // Attach categories (many-to-many)
                if (!empty($categories_ids)) {
                    $event->categories()->sync($categories_ids);
                }

                // Event history & status transitions
                if (!empty($data['organization_advisor_email'])) {
                    if ($status === 'pending - advisor approval') {
                        // Example: log event history
                        $event->histories()->create([
                            'action' => 'pending',
                            'approver_id' => $creator->id,
                            'comment' => 'Event submitted for approval.',
                        ]);
                    }
                } else {
                    // Non-student organization flow not supported yet
                    if ($action === 'publish') {
                        abort(403, 'Event requests generated by non-student organizations are not yet supported.');
                    }
                }

                return $event;
            });
        }

    //  PIPELINE

        /**
        * Deny an event and set its status to 'rejected'.
        *
        * This method handles:
        *   - Atomic update of the event status to 'rejected' if it is not in a terminal state.
        *   - Updating the most recent pending history record with the approver and rejection comment.
        *   - Triggering audit trail processes.
        *   - Sending notifications to prior approvers and the event creator.
        *
        * Race conditions are prevented by using a conditional update
        * that only succeeds if the current status is not already terminal.
        *
        * @param array $data Denial data (e.g., 'comment').
        * @param Event $event The event to deny.
        * @param User $approver The user performing the denial.
        *
        * @return Event The updated event with refreshed status and relationships.
        */
        public function denyEvent(array $data, Event $event, User $approver): Event
        {
            $updated = Event::where('id', $event->id)
                ->whereNotIn('status', ['approved', 'withdrawn', 'cancelled', 'rejected'])
                ->update(['status' => 'rejected']);
            if ($updated === 0) return $event; // stop if race condition occurred

            $this->updateLastHistory($event, $approver, $data['comment'] ?? 'unjustified rejection', 'rejected');

            // Run audit trail

            // Send rejection email to prior approvers and creator

            return $event->refresh();
        }

        /**
         * Approve an event and move it to the next approval stage.
         *
         * This method handles:
         *   - Atomic update of the event status to the next stage.
         *   - Updating the most recent pending history record with the approver and action.
         *   - Creating a new pending history record if the event is not fully approved.
         *   - Sending notifications to the next approver(s).
         *
         * Race conditions are prevented by using a conditional update
         * that only succeeds if the current status matches the expected value.
         *
         * @param array $data Approval data (e.g., 'comment').
         * @param Event $event The event to approve.
         * @param User $approver The user performing the approval.
         *
         * @return Event The updated event with refreshed status and relationships.
         *
         * @throws \InvalidArgumentException If the event has an invalid or unexpected status.
         */
        public function approveEvent(array $data, Event $event, User $approver): Event
        {
            return DB::transaction(function () use ($data, $event, $approver) {
                $statusFlow = [
                    'pending - advisor approval' => 'pending - venue manager approval',
                    'pending - venue manager approval' => 'pending - dsca approval',
                    'pending - dsca approval' => 'pending - deanship of administration approval',
                    'pending - deanship of administration approval' => 'approved',
                ];

                $currentStatus = $event->status;

                if (!isset($statusFlow[$currentStatus])) {
                    throw new \InvalidArgumentException('Event contains an invalid status');
                }

                $nextStatus = $statusFlow[$currentStatus];

                // Atomic update
                $updated = $this->updateEventStatus($event, $currentStatus, $nextStatus);
                if ($updated === 0) return $event; // stop if race condition occurred

                // Update last history record
                $this->updateLastHistory($event, $approver, $data['comment'] ?? null, 'approved');

                // Run audit trail


                // Create new pending history only if not final approval
                if ($nextStatus !== 'approved') {
                    $this->createPendingHistory($event, $nextStatus);

                    // Send notification to next approver
                }
                else {
                    // Send notification to next approver

                }
                return $event->refresh();
            });
        }

        /**
         * Atomically update event status if current status matches
         */
        protected function updateEventStatus(Event $event, string $currentStatus, string $nextStatus): int
        {
            return Event::where('id', $event->id)
                ->where('status', $currentStatus)
                ->update(['status' => $nextStatus]);
        }

        /**
         * Update the most recent pending history record
         */
        protected function updateLastHistory(Event $event, User $approver, ?string $comment = null, string $action)
        {
            $lastHistory = $event->histories()
                ->where('action', 'pending')
                ->latest()
                ->first();

            if ($lastHistory) {
                $lastHistory->update([
                    'approver_id' => $approver->id,
                    'action' => $action,
                    'comment' => $comment ?? 'Approved and forwarded to next approver.',
                ]);
            }
        }

        /**
         * Create a new pending history for the next approver
         */
        protected function createPendingHistory(Event $event, string $nextStatus)
        {
            $event->histories()->create([
                'action' => 'pending',
                'approver_id' => null,
                'comment' => "pending {$nextStatus}.",
            ]);
        }


    // Creator withdrawal or cancellation





    // Completion method




    // Dashboards




    // Administrator's overrides





    // GET
}
